(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{496:function(e,n,t){__NEXT_REGISTER_PAGE("/docs/advanced",function(){return e.exports=t(526),{page:e.exports.default}})},526:function(e,n,t){"use strict";t.r(n);var a=t(0),o=t.n(a),r=t(1),s=t(24),m=t(62);function c(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var p=function(e){var n=e.components;c(e,["components"]);return o.a.createElement(r.MDXTag,{name:"wrapper",components:n},o.a.createElement(r.MDXTag,{name:"h2",components:n},"Theming"),o.a.createElement(r.MDXTag,{name:"p",components:n},"styled-components has full theming support by exporting a ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"<ThemeProvider>")," wrapper component.\nThis component provides a theme to all React components underneath itself via the context API. In the render\ntree all styled-components will have access to the provided theme, even when they are multiple levels deep."),o.a.createElement(r.MDXTag,{name:"p",components:n},"To illustrate this, let's create our Button component, but this time we'll pass some variables down\nas a theme."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-react",metaString:""}},'// Define our button, but with the use of props.theme this time\nconst Button = styled.button`\n  font-size: 1em;\n  margin: 1em;\n  padding: 0.25em 1em;\n  border-radius: 3px;\n\n  /* Color the border and text with theme.main */\n  color: ${props => props.theme.main};\n  border: 2px solid ${props => props.theme.main};\n`;\n\n// We are passing a default theme for Buttons that arent wrapped in the ThemeProvider\nButton.defaultProps = {\n  theme: {\n    main: "palevioletred"\n  }\n}\n\n// Define what props.theme will look like\nconst theme = {\n  main: "mediumseagreen"\n};\n\nrender(\n  <div>\n    <Button>Normal</Button>\n\n    <ThemeProvider theme={theme}>\n      <Button>Themed</Button>\n    </ThemeProvider>\n  </div>\n);\n')),o.a.createElement(r.MDXTag,{name:"h3",components:n},"Function themes"),o.a.createElement(r.MDXTag,{name:"p",components:n},"You can also pass a function for the theme prop. This function will receive the parent theme, that is from\nanother ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"<ThemeProvider>")," higher up the tree. This way themes themselves can be made contextual."),o.a.createElement(r.MDXTag,{name:"p",components:n},"This example renders our above themed Button and a second one that uses a second ThemeProvider to invert the\nbackground and foreground colours. The function ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"invertTheme")," receives the upper theme and creates a new one."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-react",metaString:""}},'// Define our button, but with the use of props.theme this time\nconst Button = styled.button`\n  color: ${props => props.theme.fg};\n  border: 2px solid ${props => props.theme.fg};\n  background: ${props => props.theme.bg};\n\n  font-size: 1em;\n  margin: 1em;\n  padding: 0.25em 1em;\n  border-radius: 3px;\n`;\n\n// Define our `fg` and `bg` on the theme\nconst theme = {\n  fg: "palevioletred",\n  bg: "white"\n};\n\n// This theme swaps `fg` and `bg`\nconst invertTheme = ({ fg, bg }) => ({\n  fg: bg,\n  bg: fg\n});\n\nrender(\n  <ThemeProvider theme={theme}>\n    <div>\n      <Button>Default Theme</Button>\n\n      <ThemeProvider theme={invertTheme}>\n        <Button>Inverted Theme</Button>\n      </ThemeProvider>\n    </div>\n  </ThemeProvider>\n);\n')),o.a.createElement(r.MDXTag,{name:"h3",components:n},"Getting the theme without styled components"),o.a.createElement(r.MDXTag,{name:"p",components:n},"If you ever need to use the current theme outside styled components (e.g. inside big components), you can use\nthe ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"withTheme")," higher order component."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-jsx",metaString:""}},"import { withTheme } from 'styled-components'\n\nclass MyComponent extends React.Component {\n  render() {\n    console.log('Current theme: ', this.props.theme)\n    // ...\n  }\n}\n\nexport default withTheme(MyComponent)\n")),o.a.createElement(r.MDXTag,{name:"h3",components:n},"The ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"h3"},"theme")," prop"),o.a.createElement(r.MDXTag,{name:"p",components:n},"A theme can also be passed down to a component using the ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"theme")," prop."),o.a.createElement(r.MDXTag,{name:"p",components:n},"This is useful to circumvent a missing ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"ThemeProvider")," or to override it."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-react",metaString:""}},'// Define our button\nconst Button = styled.button`\n  font-size: 1em;\n  margin: 1em;\n  padding: 0.25em 1em;\n  border-radius: 3px;\n\n  /* Color the border and text with theme.main */\n  color: ${props => props.theme.main};\n  border: 2px solid ${props => props.theme.main};\n`;\n\n// Define what main theme will look like\nconst theme = {\n  main: "mediumseagreen"\n};\n\nrender(\n  <div>\n    <Button theme={{ main: "royalblue" }}>Ad hoc theme</Button>\n    <ThemeProvider theme={theme}>\n      <div>\n        <Button>Themed</Button>\n        <Button theme={{ main: "darkorange" }}>Overidden</Button>\n      </div>\n    </ThemeProvider>\n  </div>\n);\n')))};function l(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var i=function(e){var n=e.components;l(e,["components"]);return o.a.createElement(r.MDXTag,{name:"wrapper",components:n},o.a.createElement(r.MDXTag,{name:"h2",components:n},"Refs | v4"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Passing a ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"ref")," prop to a styled component will give you one of two things depending on the styled target:"),o.a.createElement(r.MDXTag,{name:"ul",components:n},o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"the underlying DOM node (if targeting a basic element, e.g. ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"styled.div"),")"),o.a.createElement(r.MDXTag,{name:"li",components:n,parentName:"ul"},"a React component instance (if targeting a custom component e.g. extended from ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"React.Component"),")")),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-react",metaString:""}},'const Input = styled.input`\n  padding: 0.5em;\n  margin: 0.5em;\n  color: palevioletred;\n  background: papayawhip;\n  border: none;\n  border-radius: 3px;\n`;\n\nclass Form extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.setInputRef = (element) => {\n      this.input = element;\n    }\n  }\n\n  render() {\n    return (\n      <Input\n        ref={this.setInputRef}\n        placeholder="Hover to focus!"\n        onMouseEnter={() => this.input.base.focus()}\n      />\n    );\n  }\n}\n\nrender(\n  <Form />\n);\n')),o.a.createElement(r.MDXTag,{name:"blockquote",components:n},o.a.createElement(r.MDXTag,{name:"p",components:n,parentName:"blockquote"},"Using an older version of styled-components (v3 and lower) or of React? Use the ",o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"/docs/api#innerref-prop"}},o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"a"},"innerRef")," prop")," instead.")))};function d(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var g=function(e){var n=e.components;d(e,["components"]);return o.a.createElement(r.MDXTag,{name:"wrapper",components:n},o.a.createElement(r.MDXTag,{name:"h2",components:n},"Security"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Since styled-components allows you to use arbitrary input as interpolations, you must be\ncareful to sanitize that input. Using user input as styles can lead to any CSS being evaluated in the user's\nbrowser that an attacker can place in your application."),o.a.createElement(r.MDXTag,{name:"p",components:n},"This example shows how bad user input can even lead to API endpoints being called on a user's\nbehalf."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-jsx",metaString:""}},"// Oh no! The user has given us a bad URL!\nconst userInput = '/api/withdraw-funds'\n\nconst ArbitraryComponent = styled.div`\n  background: url(${userInput});\n  /* More styles here... */\n`\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"Be very careful! This is obviously a made-up example, but CSS injection can be unobvious and\nhave bad repercussions. Some IE versions even execute arbitrary JavaScript within url declarations."),o.a.createElement(r.MDXTag,{name:"p",components:n},"There is an upcoming standard to sanitize CSS from JavaScript, ",o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"https://developer.mozilla.org/en-US/docs/Web/API/CSS/escape"}},o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"a"},"CSS.escape")),". It's not very well supported across browsers yet, so we recommend using the ",o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"https://github.com/mathiasbynens/CSS.escape"}},"polyfill by Mathias Bynens")," in your app."))};function h(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var u=function(e){var n=e.components;h(e,["components"]);return o.a.createElement(r.MDXTag,{name:"wrapper",components:n},o.a.createElement(r.MDXTag,{name:"h2",components:n},"Existing CSS"),o.a.createElement(r.MDXTag,{name:"p",components:n},"There are a couple of implementation details that you should be aware of, if you choose to use\nstyled-components together with existing CSS."),o.a.createElement(r.MDXTag,{name:"p",components:n},"styled-components generates an actual stylesheet with classes, and attaches those classes to\nthe DOM nodes of styled components via the ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"className")," prop.\nIt injects the generated stylesheet at the end of the head of the document during runtime."),o.a.createElement(r.MDXTag,{name:"h3",components:n},"Styling normal React components"),o.a.createElement(r.MDXTag,{name:"p",components:n},"If you use the ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"styled(MyComponent)")," notation and ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"MyComponent")," does not\nrender the passed-in ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"className")," prop, then no styles will be applied.\nTo avoid this issue, make sure your component attaches the passed-in className to a DOM node:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-jsx",metaString:""}},"class MyComponent extends React.Component {\n  render() {\n    // Attach the passed-in className to the DOM node\n    return <div className={this.props.className} />\n  }\n}\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"If you have pre-existing styles with a class, you can combine the global class with the\npassed-in one:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-jsx",metaString:""}},"class MyComponent extends React.Component {\n  render() {\n    // Attach the passed-in className to the DOM node\n    return <div className={`some-global-class ${this.props.className}`} />\n  }\n}\n")),o.a.createElement(r.MDXTag,{name:"h3",components:n},"Issues with specificity"),o.a.createElement(r.MDXTag,{name:"p",components:n},"If you apply a global class together with a styled component class, the result might not be\nwhat you're expecting. If a property is defined in both classes with the same specificity,\nthe last one will win."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-jsx",metaString:""}},'// MyComponent.js\nconst MyComponent = styled.div`background-color: green;`;\n\n// my-component.css\n.red-bg {\n  background-color: red;\n}\n\n// For some reason this component still has a green background,\n// even though you\'re trying to override it with the "red-bg" class!\n<MyComponent className="red-bg" />\n')),o.a.createElement(r.MDXTag,{name:"p",components:n},"In the above example the styled component class takes precedence over the global class, since\nstyled-components injects its styles during runtime at the end of the ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"<head>")," by default.\nThus its styles win over other single classname selectors."),o.a.createElement(r.MDXTag,{name:"p",components:n},"One solution is to bump up the specificity of the selectors in your stylesheet:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-css",metaString:""}},"/* my-component.css */\n.red-bg.red-bg {\n  background-color: red;\n}\n")),o.a.createElement(r.MDXTag,{name:"h3",components:n},"Avoiding conflicts with third-party styles and scripts"),o.a.createElement(r.MDXTag,{name:"p",components:n},"If you deploy styled-components on a page you don't fully control, you may need to take\nprecautions to ensure that your component styles don't conflict with those of the host page."),o.a.createElement(r.MDXTag,{name:"p",components:n},"The most common problem is insufficient specificity. For example, consider a host page with this\nstyle rule:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-css",metaString:""}},"body.my-body button {\n  padding: 24px;\n}\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"Since the rule contains a classname and two tag names, it has higher specificity than the single\nclassname selector generated by this styled component:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-jsx",metaString:""}},"styled.button`\n  padding: 16px;\n`\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"There's no way to give your components complete immunity from the host page's styles, but you can\nat least boost the specificity of their style rules with\n",o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"https://github.com/QuickBase/babel-plugin-styled-components-css-namespace"}},"babel-plugin-styled-components-css-namespace"),",\nwhich allows you to specify a CSS namespace for all of your styled components. A good namespace\nwould be something like ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"#my-widget"),", if all of your styled-components render in a container\nwith ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},'id="my-widget"'),", since ID selectors have more specificity than any number of classnames."),o.a.createElement(r.MDXTag,{name:"p",components:n},"A rarer problem is conflicts between two instances of styled-components on the page. You can avoid\nthis by defining ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"process.env.SC_ATTR")," in the code bundle with your styled-components instance.\nThis value overrides the default ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"<style>")," tag attribute, ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"data-styled")," (",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"data-styled-components")," in v3 and lower), allowing\neach styled-components instance to recognize its own tags."))};function y(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var f=function(e){var n=e.components;y(e,["components"]);return o.a.createElement(r.MDXTag,{name:"wrapper",components:n},o.a.createElement(r.MDXTag,{name:"h2",components:n},"Media Templates"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Media queries are an indispensable tool when developing responsive web apps."),o.a.createElement(r.MDXTag,{name:"p",components:n},"This is a very simple example. It shows a basic component changing its background colour,\nonce the screen's width drops below a threshold of ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"700px"),"."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-react",metaString:""}},"const Content = styled.div`\n  background: papayawhip;\n  height: 3em;\n  width: 3em;\n\n  @media (max-width: 700px) {\n    background: palevioletred;\n  }\n`;\n\nrender(\n  <Content />\n);\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"Since media queries are long and are often repeated throughout an application, it can be\nuseful to create a template for them."),o.a.createElement(r.MDXTag,{name:"p",components:n},"Due to the functional nature of JavaScript, you can easily define your own tagged template\nliteral to wrap styles in media queries. Let's rewrite the last example to try just that out."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-react",metaString:""}},"const sizes = {\n  desktop: 992,\n  tablet: 768,\n  phone: 576,\n}\n\n// Iterate through the sizes and create a media template\nconst media = Object.keys(sizes).reduce((acc, label) => {\n  acc[label] = (...args) => css`\n    @media (max-width: ${sizes[label] / 16}em) {\n      ${css(...args)}\n    }\n  `\n\n  return acc\n}, {})\n\nconst Content = styled.div`\n  height: 3em;\n  width: 3em;\n  background: papayawhip;\n\n  /* Now we have our methods on media and can use them instead of raw queries */\n  ${media.desktop`background: dodgerblue;`}\n  ${media.tablet`background: mediumseagreen;`}\n  ${media.phone`background: palevioletred;`}\n`;\n\nrender(\n  <Content />\n);\n")))};function T(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var b=function(e){var n=e.components;T(e,["components"]);return o.a.createElement(r.MDXTag,{name:"wrapper",components:n},o.a.createElement(r.MDXTag,{name:"h2",components:n},"Tagged Template Literals"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Tagged Template Literals are a new feature in ES6. They let you define custom string interpolation rules,\nwhich is how we're able to create styled components."),o.a.createElement(r.MDXTag,{name:"p",components:n},"If you pass no interpolations, the first argument your function receives is an array with a string in it."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-jsx",metaString:""}},"// These are equivalent:\nfn`some string here`\nfn(['some string here'])\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"Once you pass interpolations, the array contains the passed string, split at the positions of the interpolations.\nThe rest of the arguments will be the interpolations, in order."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-jsx",metaString:""}},"const aVar = 'good'\n\n// These are equivalent:\nfn`this is a ${aVar} day`\nfn(['this is a ', ' day'], aVar)\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"This is a bit cumbersome to work with, but it means that we can receive variables, functions, or mixins\n(",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"css")," helper) in styled components and can flatten that into pure CSS."),o.a.createElement(r.MDXTag,{name:"p",components:n},"If you want to learn more about tagged template literals, check out Max Stoiber's article:\n",o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"https://mxstbr.blog/2016/11/styled-components-magic-explained/"}},"The magic behind ðŸ’… styled-components")))};function E(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var M=function(e){var n=e.components;E(e,["components"]);return o.a.createElement(r.MDXTag,{name:"wrapper",components:n},o.a.createElement(r.MDXTag,{name:"h2",components:n},"Server Side Rendering | v2+"),o.a.createElement(r.MDXTag,{name:"p",components:n},"styled-components supports concurrent server side rendering, with stylesheet rehydration.\nThe basic idea is that everytime you render your app on the server, you can create\na ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"ServerStyleSheet")," and add a provider to your React tree, that accepts styles\nvia a context API."),o.a.createElement(r.MDXTag,{name:"p",components:n},"This doesn't interfere with global styles, such as ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"keyframes")," or ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"injectGlobal")," and\nallows you to use styled-components with React DOM's SSR, or even Rapscallion."),o.a.createElement(r.MDXTag,{name:"p",components:n},"The basic API goes as follows:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-jsx",metaString:""}},"import { renderToString } from 'react-dom/server'\nimport { ServerStyleSheet } from 'styled-components'\n\nconst sheet = new ServerStyleSheet()\nconst html = renderToString(sheet.collectStyles(<YourApp />))\nconst styleTags = sheet.getStyleTags() // or sheet.getStyleElement();\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"The ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"collectStyles")," method wraps your element in a provider. Optionally you can use\nthe ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"StyleSheetManager")," provider directly, instead of this method. Just make sure not to\nuse it on the client-side."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-jsx",metaString:""}},"import { renderToString } from 'react-dom/server'\nimport { ServerStyleSheet, StyleSheetManager } from 'styled-components'\n\nconst sheet = new ServerStyleSheet()\nconst html = renderToString(\n  <StyleSheetManager sheet={sheet.instance}>\n    <YourApp />\n  </StyleSheetManager>,\n)\n\nconst styleTags = sheet.getStyleTags() // or sheet.getStyleElement();\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"The ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"sheet.getStyleTags()")," returns a string of multiple ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"<style>")," tags.\nYou need to take this into account when adding the CSS string to your HTML output."),o.a.createElement(r.MDXTag,{name:"p",components:n},"Alternatively the ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"ServerStyleSheet")," instance also has a ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"getStyleElement()")," method\nthat returns an array of React elements."),o.a.createElement(r.MDXTag,{name:"blockquote",components:n},o.a.createElement(r.MDXTag,{name:"p",components:n,parentName:"blockquote"},o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"sheet.getStyleTags()")," and ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"sheet.getStyleElement()")," can only be called after your element is rendered. As a result, components from ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"sheet.getStyleElement()")," cannot be combined with ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"<YourApp />")," into a larger component.")),o.a.createElement(r.MDXTag,{name:"p",components:n},"You should install and use our babel plugin with its ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"ssr")," option turned on.\nThis prevents checksum mismatches by adding a deterministic ID to each styled component.\nRefer to the ",o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"/docs/tooling#serverside-rendering"}},"tooling documentation")," for more information."),o.a.createElement(r.MDXTag,{name:"h3",components:n},"Next.js"),o.a.createElement(r.MDXTag,{name:"p",components:n},"Basically you need to add a custom ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"pages/_document.js")," (if you don't have one). Then\n",o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"https://github.com/zeit/next.js/tree/master/examples/with-styled-components/pages/_document.js"}},"copy the logic"),"\nfor styled-components to inject the server side rendered styles into the ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"<head>"),"."),o.a.createElement(r.MDXTag,{name:"p",components:n},"Refer to ",o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"https://github.com/zeit/next.js/tree/master/examples/with-styled-components"}},"our example")," in the Next.js repo for an up-to-date usage example."),o.a.createElement(r.MDXTag,{name:"h3",components:n},"Streaming Rendering"),o.a.createElement(r.MDXTag,{name:"p",components:n},"styled-components offers a streaming API for use with ",o.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"https://reactjs.org/docs/react-dom-server.html#rendertonodestream"}},"ReactDOMServer.renderToNodeStream()"),". There are two parts to a streaming implementation:"),o.a.createElement(r.MDXTag,{name:"p",components:n},o.a.createElement(r.MDXTag,{name:"em",components:n,parentName:"p"},"On the server:")),o.a.createElement(r.MDXTag,{name:"p",components:n},o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"ReactDOMServer.renderToNodeStream"),' emits a "readable" stream that styled-components wraps. As whole chunks of HTML are pushed onto the stream, if any corresponding styles are ready to be rendered, a style block is prepended to React\'s HTML and forwarded on to the client browser.'),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js",metaString:""}},"import { renderToNodeStream } from 'react-dom/server'\nimport styled, { ServerStyleSheet } from 'styled-components'\n\n// if you're using express.js, you'd have access to the response object \"res\"\n\n// typically you'd want to write some preliminary HTML, since React doesn't handle this\nres.write('<html><head><title>Test</title></head><body>')\n\nconst Heading = styled.h1`\n  color: red;\n`\n\nconst sheet = new ServerStyleSheet()\nconst jsx = sheet.collectStyles(<Heading>Hello SSR!</Heading>)\nconst stream = sheet.interleaveWithNodeStream(renderToNodeStream(jsx))\n\n// you'd then pipe the stream into the response object until it's done\nstream.pipe(\n  res,\n  { end: false },\n)\n\n// and finalize the response with closing HTML\nstream.on('end', () => res.end('</body></html>'))\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},o.a.createElement(r.MDXTag,{name:"em",components:n,parentName:"p"},"On the client:")),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js",metaString:""}},"import { hydrate } from 'react-dom'\n\nhydrate()\n// your client-side react implementation\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"After client-side rehydration is complete, styled-components will take over as usual and inject any further dynamic styles after the relocated streaming ones."))};function v(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var D=function(e){var n=e.components;v(e,["components"]);return o.a.createElement(r.MDXTag,{name:"wrapper",components:n},o.a.createElement(r.MDXTag,{name:"h2",components:n},"Referring to other components"),o.a.createElement(r.MDXTag,{name:"p",components:n},"There are many ways to apply contextual overrides to a component's styling. That being said,\nit rarely is easy without rigging up a well-known targeting CSS selector paradigm\nand then making them accessible for use in interpolations."),o.a.createElement(r.MDXTag,{name:"p",components:n},'styled-components solves this use case cleanly via the "component selector" pattern. Whenever\na component is created or wrapped by the styled() factory function, it is also assigned a\nstable CSS class for use in targeting. This allows for extremely powerful composition patterns\nwithout having to fuss around with naming and avoiding selector collisions.'),o.a.createElement(r.MDXTag,{name:"p",components:n},"A practical example: here, our Icon component defines its response to the parent Link being hovered:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-react",metaString:""}},'const Link = styled.a`\n  display: flex;\n  align-items: center;\n  padding: 5px 10px;\n  background: papayawhip;\n  color: palevioletred;\n`;\n\nconst Icon = styled.svg`\n  transition: fill 0.25s;\n  width: 48px;\n  height: 48px;\n\n  ${Link}:hover & {\n    fill: rebeccapurple;\n  }\n`;\n\nconst Label = styled.span`\n  display: flex;\n  align-items: center;\n  line-height: 1.2;\n\n  &::before {\n    content: \'â—€\';\n    margin: 0 10px;\n  }\n`;\n\nrender(\n  <Link href="#">\n    <Icon viewBox="0 0 20 20">\n      <path d="M10 15h8c1 0 2-1 2-2V3c0-1-1-2-2-2H2C1 1 0 2 0 3v10c0 1 1 2 2 2h4v4l4-4zM5 7h2v2H5V7zm4 0h2v2H9V7zm4 0h2v2h-2V7z"/>\n    </Icon>\n    <Label>Hovering my parent changes my style!</Label>\n  </Link>\n);\n')),o.a.createElement(r.MDXTag,{name:"p",components:n},"We could have nested the color-changing rule within our Link component, but then we'd have to\nconsider both sets of rules to understand why Icon behaves as it does."),o.a.createElement(r.MDXTag,{name:"h3",components:n},"Caveat"),o.a.createElement(r.MDXTag,{name:"p",components:n},"This behaviour is only supported within the context of ",o.a.createElement(r.MDXTag,{name:"em",components:n,parentName:"p"},"Styled")," Components:\nattempting to mount ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"B")," in the following example will fail because component\n",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"A")," is an instance of React.Component not a Styled Component."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-jsx",metaString:""}},"class A extends React.Component {\n  render() {\n    return <div />\n  }\n}\n\nconst B = styled.div`\n  ${A} {\n  }\n`\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"The error thrown - ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"Cannot call a class as a function")," - occurs because the\nstyled component is attempting to call the component as an interpolation function."),o.a.createElement(r.MDXTag,{name:"p",components:n},"However, wrapping ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"A")," in a styled() factory makes it eligible for interpolation -- just\nmake sure the wrapped component passes along ",o.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"className"),"."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-jsx",metaString:""}},"class A extends React.Component {\n  render() {\n    return <div className={this.props.className} />\n  }\n}\n\nconst StyledA = styled(A)``\n\nconst B = styled.div`\n  ${StyledA} {\n  }\n`\n")))};function w(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}n.default=function(e){var n=e.components,t=w(e,["components"]);return o.a.createElement(r.MDXTag,{name:"wrapper",Layout:function(e){var n=e.children;return o.a.createElement(s.a,{title:"Advanced",description:"Advanced usage of styled-components - Theming, refs, Security, Existing CSS, Media Templates, Tagged Template Literals, SSR"},n)},layoutProps:t,components:n},o.a.createElement(p,null),o.a.createElement(i,null),o.a.createElement(g,null),o.a.createElement(u,null),o.a.createElement(f,null),o.a.createElement(b,null),o.a.createElement(M,null),o.a.createElement(D,null),o.a.createElement(m.a,{href:"/docs/api",title:"API Reference"}))}},62:function(e,n,t){"use strict";var a=t(0),o=t.n(a),r=t(2),s=function(e,n){return Object.defineProperty?Object.defineProperty(e,"raw",{value:n}):e.raw=n,e},m=r.d.svg.attrs({children:function(e){return null!=e.title?[o.a.createElement("title",{key:"KeyboardArrowRight-title"},e.title),o.a.createElement("path",{d:"M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z",key:"k0"})]:[o.a.createElement("path",{d:"M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z",key:"k0"})]},viewBox:"0 0 24 24",height:function(e){return void 0!==e.height?e.height:e.size},width:function(e){return void 0!==e.width?e.width:e.size},"aria-hidden":function(e){return null==e.title?"true":void 0},focusable:"false",role:function(e){return null!=e.title?"img":void 0},fill:"currentColor"})(c||(c=s(["\n  display: inline-block;\n  vertical-align: middle;\n  overflow: hidden;\n"],["\n  display: inline-block;\n  vertical-align: middle;\n  overflow: hidden;\n"])));m.displayName="KeyboardArrowRight";var c,p=t(3),l=t(10),i=t(4),d=t(6),g=t(5),h=Object(r.d)(l.b).attrs({unstyled:!0,prefetch:!0}).withConfig({displayName:"NextPage__Wrapper",componentId:"xdq90t-0"})(["display:flex;flex-direction:row;align-items:stretch;justify-content:flex-end;width:100%;padding:"," ",";text-align:right;font-family:",";",";"],Object(p.a)(40),Object(p.a)(20),g.b,Object(d.a)(Object(r.c)(["text-align:left;justify-content:center;padding:"," ",";"],Object(p.a)(30),Object(p.a)(20)))),u=r.d.h3.withConfig({displayName:"NextPage__Text",componentId:"xdq90t-1"})(["font-weight:normal;padding-right:",";margin:0;"],Object(p.a)(20)),y=r.d.h2.withConfig({displayName:"NextPage__PageName",componentId:"xdq90t-2"})(["font-weight:600;padding-right:",";margin:0;"],Object(p.a)(20)),f=Object(r.d)(m).withConfig({displayName:"NextPage__Icon",componentId:"xdq90t-3"})(["color:",";width:",";"],i.c,Object(p.a)(30));n.a=function(e){var n=e.title,t=e.href;return o.a.createElement(h,{unstyled:!0,prefetch:!0,href:t},o.a.createElement("div",null,o.a.createElement(u,null,"Continue on the next page"),o.a.createElement(y,null,n)),o.a.createElement("div",null,o.a.createElement(f,null)))}}},[[496,1,0]]]);